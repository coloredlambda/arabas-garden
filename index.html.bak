<html lang="en" vid="0"><head vid="1">
    <meta charset="UTF-8" vid="2">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" vid="3">
    <title vid="4">Wildflower Meadow Study</title>
    <script src="https://cdn.tailwindcss.com/3.4.17" vid="5"></script>
    <style vid="6">
        :root {
            
            --paper-base: #fbf9f2; 
            --ink-dark: #3a3228;
            --ink-accent: #6b5e52;
            --text-color: #594a3e;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--paper-base);
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, serif;
        }

        .paper-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.5;
            mix-blend-mode: multiply;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        canvas {
            display: block;
        }

        .ui-layer {
            position: absolute;
            bottom: 40px;
            right: 50px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            text-align: right;
            max-width: 400px;
            pointer-events: none;
        }

        h1 {
            font-weight: normal;
            font-size: 1.4rem;
            color: var(--ink-dark);
            margin: 0 0 12px 0;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            opacity: 0;
            animation: fadeIn 2.5s 3s forwards ease-out;
            border-bottom: 1px solid rgba(89, 74, 62, 0.2);
            padding-bottom: 8px;
            display: inline-block;
        }

        .poem-content {
            font-size: 1.05rem;
            font-style: italic;
            color: var(--text-color);
            opacity: 0;
            transition: opacity 2s ease-out;
            line-height: 1.7;
        }

        .poem-content.visible {
            opacity: 0.85;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .svg-defs {
            position: absolute;
            width: 0;
            height: 0;
        }
    </style>
</head>
<body vid="7">
    <svg class="svg-defs" vid="8">
        
        <filter id="paper-noise" vid="9">
            <feTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" result="noise" vid="10"></feTurbulence>
            <feColorMatrix type="matrix" values="1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0.25 0" in="noise" result="coloredNoise" vid="11"></feColorMatrix>
            <feComposite operator="in" in="coloredNoise" in2="SourceGraphic" result="composite" vid="12"></feComposite>
        </filter>
        
        
        <filter id="watercolor" vid="13">
            <feTurbulence type="fractalNoise" baseFrequency="0.035" numOctaves="5" result="noise" vid="14"></feTurbulence>
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="16" vid="15"></feDisplacementMap>
            <feGaussianBlur stdDeviation="0.7" vid="16"></feGaussianBlur>
            <feComponentTransfer vid="17">
                <feFuncA type="linear" slope="1.1" intercept="0" vid="18"></feFuncA>
            </feComponentTransfer>
        </filter>
    </svg>

    <div class="paper-texture" vid="19">
        <svg width="100%" height="100%" vid="20">
            <rect width="100%" height="100%" filter="url(#paper-noise)" opacity="0.4" vid="21"></rect>
        </svg>
    </div>

    <div class="canvas-container" vid="22">
        <canvas id="artCanvas" vid="23"></canvas>
    </div>

    <div class="ui-layer" vid="24">
        <h1 vid="25">Meadow Study No. 4</h1>
        <div class="poem-content" id="poemText" vid="26">
            The earth laughs in flowers,<br vid="27">
            A wild, chaotic chorus of color<br vid="28">
            Singing to the open sky.
        </div>
    </div>

    <script vid="29">
        const displayCanvas = document.getElementById('artCanvas');
        const displayCtx = displayCanvas.getContext('2d', { alpha: true, desynchronized: true });
        const paintCanvas = document.createElement('canvas');
        const paintCtx = paintCanvas.getContext('2d', { alpha: true });
        const poemEl = document.getElementById('poemText');

        const COMPOSITE_FILTER = 'url(#watercolor) blur(0.3px)';
        const FLOWER_TYPE_COUNT = 5;

        let width, height;
        let animationId;
        let resizeRafId = null;
        let poemShown = false;

        
        const PALETTE = {
            ground: [
                {h: 85, s: 30, l: 85}, 
                {h: 75, s: 25, l: 80}, 
                {h: 95, s: 20, l: 75}  
            ],
            stems: [
                {h: 95, s: 35, l: 40},  
                {h: 80, s: 40, l: 45},  
                {h: 110, s: 30, l: 35}, 
                {h: 45, s: 35, l: 50}   
            ],
            flowers: [
                {h: 12, s: 85, l: 62},  
                {h: 215, s: 70, l: 65}, 
                {h: 42, s: 95, l: 65},  
                {h: 275, s: 45, l: 68}, 
                {h: 335, s: 75, l: 70}, 
                {h: 25, s: 90, l: 60}   
            ],
            centers: {h: 45, s: 80, l: 45}, 
            leaves: {h: 100, s: 35, l: 42}
        };

        class Brush {
            constructor(ctx) {
                this.ctx = ctx;
            }
            
            
            stroke(x1, y1, x2, y2, color, width, opacity) {
                this.ctx.beginPath();
                this.ctx.moveTo(x1, y1);
                this.ctx.lineTo(x2, y2);
                
                
                const h = color.h + (Math.random() * 8 - 4);
                const s = color.s + (Math.random() * 10 - 5);
                const l = color.l + (Math.random() * 10 - 5);
                
                this.ctx.strokeStyle = `hsla(${h}, ${s}%, ${l}%, ${opacity})`;
                this.ctx.lineWidth = width * (0.85 + Math.random() * 0.3);
                this.ctx.lineCap = 'round';
                this.ctx.stroke();
            }

            
            blob(x, y, radius, color, opacity, angle, stretch) {
                const baseAngle = angle == null ? Math.random() * Math.PI : angle;
                const baseStretch = stretch == null ? (1.1 + Math.random() * 0.2) : stretch;
                
                
                const passes = 2;
                for (let i = 0; i < passes; i++) {
                    const jx = (Math.random() - 0.5) * radius * 0.4;
                    const jy = (Math.random() - 0.5) * radius * 0.4;
                    const r = Math.max(0.5, radius * (0.8 + Math.random() * 0.4));
                    const rx = r * baseStretch;
                    const ry = r * (0.7 + Math.random() * 0.3);
                    const h = color.h + (Math.random() * 12 - 6);
                    const l = color.l + (Math.random() * 8 - 4);
                    const a = baseAngle + (Math.random() - 0.5) * 0.2;
                    
                    this.ctx.beginPath();
                    this.ctx.ellipse(x + jx, y + jy, rx, ry, a, 0, Math.PI * 2);
                    this.ctx.fillStyle = `hsla(${h}, ${color.s}%, ${l}%, ${opacity})`;
                    this.ctx.fill();
                }
            }

            
            wash(x, y, width, height, color, opacity) {
                const grd = this.ctx.createRadialGradient(x, y, 0, x, y, width);
                grd.addColorStop(0, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${opacity})`);
                grd.addColorStop(1, `hsla(${color.h}, ${color.s}%, ${color.l}%, 0)`);
                
                this.ctx.fillStyle = grd;
                this.ctx.save();
                this.ctx.translate(x, y);
                this.ctx.scale(1, height/width);
                this.ctx.beginPath();
                this.ctx.arc(0, 0, width, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }
        }

        class Stem {
            constructor(x, y, height, scale) {
                this.x = x;
                this.y = y;
                this.scale = scale;
                this.targetHeight = height;
                this.currentHeight = 0;
                this.segments = [];
                this.growSpeed = 1.5 + Math.random() * 2;
                this.done = false;
                this.type = Math.random() > 0.3 ? 'flower' : 'grass'; 
                this.color = PALETTE.stems[Math.floor(Math.random() * PALETTE.stems.length)];
                
                
                this.swayFreq = 0.02 + Math.random() * 0.03;
                this.swayPhase = Math.random() * Math.PI * 2;
                this.swayAmp = (Math.random() * 0.3) * this.scale;

                
                let cx = x;
                let cy = y;
                
                let ca = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                const stepSize = 6 * scale;
                const totalSteps = Math.floor(height / stepSize);

                this.leaves = [];
                
                for(let i = 0; i < totalSteps; i++) {
                    
                    ca += (Math.random() - 0.5) * 0.12;
                    
                    if (ca < -Math.PI/2 - 0.5) ca += 0.05;
                    if (ca > -Math.PI/2 + 0.5) ca -= 0.05;

                    let nx = cx + Math.cos(ca) * stepSize;
                    let ny = cy + Math.sin(ca) * stepSize;
                    
                    this.segments.push({
                        x: nx,
                        y: ny,
                        angle: ca
                    });

                    
                    if (this.type === 'flower' && i > totalSteps * 0.2 && i < totalSteps * 0.85 && Math.random() < 0.15) {
                        this.addLeaf(nx, ny, ca, i);
                    } else if (this.type === 'grass' && i > totalSteps * 0.3 && Math.random() < 0.25) {
                        this.addLeaf(nx, ny, ca, i, true);
                    }

                    cx = nx;
                    cy = ny;
                }
                this.tip = {x: cx, y: cy};
            }

            addLeaf(x, y, angle, index, isGrass = false) {
                const side = Math.random() < 0.5 ? -1 : 1;
                const leafAngle = angle + side * (0.5 + Math.random() * 0.6);
                const length = isGrass ? (20 + Math.random() * 30) * this.scale : (15 + Math.random() * 20) * this.scale;
                const width = isGrass ? (2 + Math.random() * 2) * this.scale : (4 + Math.random() * 4) * this.scale;
                
                if (!this.leaves[index]) this.leaves[index] = [];
                this.leaves[index].push({
                    angle: leafAngle,
                    length: length,
                    width: width,
                    drawn: false,
                    cos: Math.cos(leafAngle),
                    sin: Math.sin(leafAngle),
                    isGrass: isGrass
                });
            }

            update() {
                if (this.currentHeight < this.segments.length) {
                    this.currentHeight += this.growSpeed;
                    if (this.currentHeight >= this.segments.length) {
                        this.currentHeight = this.segments.length;
                        this.done = true;
                    }
                }
                return this.done;
            }

            draw(brush) {
                const maxIndex = Math.floor(this.currentHeight);
                if (maxIndex < 1) return;
                
                const drawEnd = this.hasFlower ? Math.max(1, maxIndex - 1) : maxIndex;
                const startIdx = Math.max(1, drawEnd - Math.ceil(this.growSpeed) - 1);
                
                for(let i = startIdx; i < drawEnd; i++) {
                    const prev = this.segments[i-1];
                    const curr = this.segments[i];
                    
                    const t = i / this.segments.length;
                    const width = (this.type === 'grass' ? 2.5 : 4.0) * this.scale * (1 - t * 0.6);

                    
                    brush.stroke(prev.x, prev.y, curr.x, curr.y, this.color, width, 0.25);
                    
                    brush.stroke(prev.x, prev.y, curr.x, curr.y, {...this.color, l: this.color.l - 10}, width * 0.6, 0.15);

                    
                    if (this.leaves[i]) {
                        for (let leaf of this.leaves[i]) {
                            if (!leaf.drawn) {
                                this.drawLeaf(brush, curr.x, curr.y, leaf);
                                leaf.drawn = true;
                            }
                        }
                    }
                }
            }

            drawLeaf(brush, x, y, leaf) {
                const tipX = x + leaf.cos * leaf.length;
                const tipY = y + leaf.sin * leaf.length;
                const midX = x + leaf.cos * (leaf.length * 0.5);
                const midY = y + leaf.sin * (leaf.length * 0.5);
                
                
                const c = {...this.color, l: this.color.l + 5};
                
                if (leaf.isGrass) {
                    
                    brush.stroke(x, y, tipX, tipY, c, leaf.width, 0.3);
                    brush.stroke(x, y, midX, midY, {...c, l: c.l-10}, leaf.width*0.5, 0.2);
                } else {
                    
                    brush.blob(midX, midY, leaf.width * 2, c, 0.15, leaf.angle, 2.5);
                    brush.stroke(x, y, tipX, tipY, {...c, l: c.l-15}, leaf.width * 0.3, 0.2);
                }
            }
        }

        class Flower {
            constructor(x, y, scale) {
                this.x = x;
                this.y = y;
                this.scale = scale;
                this.age = 0;
                this.maxAge = 100 + Math.random() * 50;
                this.type = Math.floor(Math.random() * FLOWER_TYPE_COUNT);
                
                
                const colorIdx = Math.floor(Math.random() * PALETTE.flowers.length);
                this.mainColor = PALETTE.flowers[colorIdx];
                
                this.secColor = PALETTE.flowers[(colorIdx + 1) % PALETTE.flowers.length];
                
                this.petals = [];
                this.centers = [];
                this.generateShape();
            }

            generateShape() {
                
                
                
                
                
                
                
                const count = this.type === 0 ? 4 : (this.type === 1 ? 12 : (this.type === 2 ? 8 : (this.type === 3 ? 20 : 6)));
                
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 / count) * i + (Math.random() - 0.5) * 0.5;
                    
                    let dist = 10 * this.scale;
                    let radius = 10 * this.scale;
                    let stretch = 1.5;
                    
                    if (this.type === 0) { 
                        dist = 8 * this.scale;
                        radius = 15 * this.scale;
                        stretch = 1.2;
                    } else if (this.type === 1) { 
                        dist = 12 * this.scale;
                        radius = 4 * this.scale;
                        stretch = 2.5;
                    } else if (this.type === 3) { 
                        dist = 5 * this.scale;
                        radius = 8 * this.scale;
                        stretch = 3.0; 
                    }

                    this.petals.push({
                        angle: angle,
                        dist: dist + Math.random() * 5 * this.scale,
                        radius: radius + Math.random() * 3 * this.scale,
                        stretch: stretch,
                        cos: Math.cos(angle),
                        sin: Math.sin(angle),
                        colorVar: Math.random()
                    });
                }

                
                const centerCount = this.type === 3 ? 15 : 5;
                for(let i=0; i<centerCount; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const d = Math.random() * 3 * this.scale;
                    this.centers.push({
                        x: Math.cos(a) * d,
                        y: Math.sin(a) * d,
                        r: (1.5 + Math.random()) * this.scale
                    });
                }
            }

            draw(brush) {
                if (this.age > this.maxAge) return;
                this.age++;
                
                const growth = Math.min(1, this.age / 60); 
                const bloom = 0.2 + growth * 0.8;

                
                const sway = Math.sin(Date.now() * 0.001 + this.x) * 2 * this.scale;
                const fx = this.x + sway;
                const fy = this.y;

                
                for (let p of this.petals) {
                    if (Math.random() > 0.6) continue; 

                    const dist = p.dist * bloom;
                    const radius = p.radius * bloom;
                    
                    const px = fx + p.cos * dist;
                    const py = fy + p.sin * dist;
                    
                    const color = p.colorVar > 0.8 ? this.secColor : this.mainColor;
                    
                    
                    brush.blob(px, py, radius, color, 0.06, p.angle, p.stretch);
                    
                    
                    if (Math.random() > 0.7) {
                        const innerX = fx + p.cos * (dist * 0.5);
                        const innerY = fy + p.sin * (dist * 0.5);
                        brush.blob(innerX, innerY, radius * 0.5, {...color, l: color.l - 10}, 0.05, p.angle, p.stretch);
                    }
                }

                
                if (growth > 0.6) {
                    for (let c of this.centers) {
                        if (Math.random() > 0.3) {
                            brush.blob(fx + c.x * bloom, fy + c.y * bloom, c.r, PALETTE.centers, 0.1, 0, 1);
                        }
                    }
                }
            }
        }

        let stems = [];
        let flowers = [];
        let brush;

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            displayCanvas.width = width;
            displayCanvas.height = height;
            paintCanvas.width = width;
            paintCanvas.height = height;
            paintCtx.lineCap = 'round';
            paintCtx.lineJoin = 'round';
        }

        function renderFrame() {
            displayCtx.clearRect(0, 0, width, height);
            displayCtx.filter = COMPOSITE_FILTER;
            displayCtx.drawImage(paintCanvas, 0, 0);
            displayCtx.filter = 'none';
        }

        function drawGround() {
            
            const groundH = height * 0.15;
            for(let i=0; i<20; i++) {
                const x = Math.random() * width;
                const y = height - Math.random() * groundH;
                const w = 100 + Math.random() * 200;
                const col = PALETTE.ground[Math.floor(Math.random() * PALETTE.ground.length)];
                brush.wash(x, y, w, w * 0.3, col, 0.05);
            }
        }

        function init() {
            cancelAnimationFrame(animationId);
            resize();
            paintCtx.clearRect(0, 0, width, height);
            
            brush = new Brush(paintCtx);
            stems = [];
            flowers = [];
            
            drawGround();

            
            
            const density = Math.floor(width / 25); 
            
            for(let i=0; i<density; i++) {
                const x = Math.random() * width;
                
                const depth = Math.random(); 
                const y = height + 10 + depth * 40;
                
                
                const scale = 0.5 + depth * 0.7; 
                
                
                const h = (height * 0.3) + Math.random() * (height * 0.4);
                
                const stem = new Stem(x, y, h * scale, scale);
                stems.push(stem);
            }

            
            stems.sort((a, b) => a.scale - b.scale);

            loop();
        }

        function loop() {
            let active = false;

            
            stems.forEach(stem => {
                const done = stem.update();
                stem.draw(brush);
                if (!done) active = true;
                else if (stem.type === 'flower' && !stem.hasFlower) {
                    
                    flowers.push(new Flower(stem.tip.x, stem.tip.y, stem.scale));
                    stem.hasFlower = true;
                    
                    if (Math.random() > 0.7 && stem.segments.length > 20) {
                         const nodeIdx = Math.floor(stem.segments.length * 0.7);
                         const node = stem.segments[nodeIdx];
                         flowers.push(new Flower(node.x + 20*stem.scale, node.y, stem.scale * 0.7));
                    }
                }
            });

            
            flowers.forEach(flower => {
                flower.draw(brush);
                if (flower.age < flower.maxAge) active = true;
            });

            renderFrame();

            if (active) {
                animationId = requestAnimationFrame(loop);
            } else {
                if (!poemShown) {
                    poemEl.classList.add('visible');
                    poemShown = true;
                }
            }
        }

        window.addEventListener('resize', () => {
            if (resizeRafId) cancelAnimationFrame(resizeRafId);
            resizeRafId = requestAnimationFrame(() => {
                
                
                init();
            });
        });

        
        setTimeout(init, 200);

    </script>

</body></html>